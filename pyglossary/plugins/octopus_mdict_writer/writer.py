# -*- coding: utf-8 -*-
from __future__ import annotations

import os
import sys
from typing import TYPE_CHECKING

from pyglossary.core import log

if TYPE_CHECKING:
	from collections.abc import Generator

	from pyglossary.glossary_types import EntryType, WriterGlossaryType


__all__ = ["Writer"]


class Writer:
	_encoding: str = "utf-8"
	_key_block_size: int = 32768  # = 32KB match original mdict-utils default
	_record_block_size: int = 65536  # = 64KB - match original mdict-utils default
	_compression_type: int = 2  # zlib - best compression we have
	_audio: bool = False  # Convert audio tags back to MDX format
	_substyle: bool = True  # Enable substyle processing

	def __init__(self, glos: WriterGlossaryType) -> None:
		self._glos = glos
		self._filename = ""
		self._entries: list[tuple[str, str]] = []  # Text entries for MDX (list to preserve duplicates)
		self._data_entries: dict[str, bytes] = {}  # Binary data entries for MDD
		# Regex patterns for link processing (similar to reader)
		import re
		self._re_internal_link = re.compile(r'href=["\']bword://([^"\']+)["\']')
		self._re_audio_link = re.compile(
			r'<audio[^>]*controls[^>]*src=["\']([^"\']+)["\'][^>]*></audio>'
		)

		# Options will be set by the framework via setattr() in _createWriter

	def finish(self) -> None:
		self._filename = ""
		self._entries = []
		self._data_entries = {}

	def fixDefi(self, defi: str) -> str:
		"""Process definition for MDX compatibility (reverse of reader transformations)."""
		# Convert bword:// links back to entry:// format
		defi = self._re_internal_link.sub(r'href="\1"', defi)

		# Convert relative paths back to file:// format
		defi = defi.replace(' src="./', ' src="file://')

		# Convert audio tags back to MDX sound:// format if audio option is enabled
		if self._audio:
			defi = self._re_audio_link.sub(
				r'<a href="sound://\1">ðŸ”Š</a>',
				defi,
			)

		return defi

	def open(self, filename: str) -> None:
		self._filename = filename

	def write(self) -> Generator[None, EntryType, None]:
		"""
		Generator that receives entries and builds MDX dictionary.
		Collects all entries, then writes proper MDX file using mdict-utils.
		"""
		while True:
			entry = yield
			if entry is None:
				break
			if entry.isData():
				# Collect data entries for MDD file
				# PyGlossary data entries have s_word (filename) and data (bytes)
				if hasattr(entry, 's_word') and hasattr(entry, 'data'):
					self._data_entries[entry.s_word] = entry.data
				continue

			# Get all terms (aliases)
			terms = entry.l_term
			if not terms:
				continue

			definition = entry.defi

			# Process definition for MDX compatibility
			definition = self.fixDefi(definition)

			# Store the entry for each term/alias
			# Use list to preserve potential duplicates (homonyms)
			for term in terms:
				self._entries.append((term, definition))

		# Now write all entries to proper MDX file
		self._writeMdxFile()

	def _writeMdxFile(self) -> None:
		"""Write collected entries to proper MDX/MDD files using mdict-utils MDictWriter."""
		if not self._entries and not self._data_entries:
			log.warning("No entries to write")
			return

		# Add mdict-utils to path
		mdict_utils_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '..', 'mdict-utils')
		if mdict_utils_path not in sys.path:
			sys.path.insert(0, mdict_utils_path)

		try:
			from .mdict_writer import MDictWriter

			# Get title and description from glossary
			title = self._glos.getInfo("name") or "PyGlossary MDX Export"
			description = self._glos.getInfo("description") or "Generated by PyGlossary"

			# Create MDX file for text entries
			if self._entries:
				# Try different compression settings to match original file
				# Original file might use different block sizes or compression
				mdx_writer = MDictWriter(
					self._entries,
					title=title,
					description=description,
					key_size=self._key_block_size,
					record_size=self._record_block_size,
					encoding=self._encoding,
					compression_type=self._compression_type,
					version="2.0",
					is_mdd=False,
					compact="Yes",
					compat="Yes"
				)

				# Write the MDX file
				with open(self._filename, "wb") as outfile:
					mdx_writer.write(outfile)

				log.info(f"Successfully wrote {len(self._entries)} text entries to {self._filename}")

			# Create MDD file for binary data entries
			if self._data_entries:
				# Create MDD filename (same as MDX but with .mdd extension)
				mdd_filename = os.path.splitext(self._filename)[0] + '.mdd'

				# Convert data entries to MDD format (list of dicts with key/path/size/pos)
				mdd_data = []
				for filename, data_bytes in self._data_entries.items():
					mdd_data.append({
						'key': filename,
						'path': data_bytes,  # For MDD, path contains the actual data
						'pos': 0,            # Not used for in-memory data
						'size': len(data_bytes)
					})

				mdd_writer = MDictWriter(
					mdd_data,  # Pass as list of dicts, not dict
					title=title,
					description=description,
					key_size=self._key_block_size,
					record_size=self._record_block_size,
					encoding="",  # MDD doesn't use text encoding
					compression_type=self._compression_type,
					version="2.0",
					is_mdd=True  # This creates MDD format
				)

				# Write the MDD file
				with open(mdd_filename, "wb") as outfile:
					mdd_writer.write(outfile)

				log.info(f"Successfully wrote {len(self._data_entries)} data entries to {mdd_filename}")

		except Exception as e:
			log.error(f"Failed to create MDX/MDD files: {e}")
			import traceback
			traceback.print_exc()
			# Fallback: create a simple text file for text entries
			if self._entries:
				with open(self._filename, 'w', encoding=self._encoding) as f:
					for term, definition in self._entries:
						f.write(f"{term}\n")
						for line in definition.split('\n'):
							f.write(f"{line}\n")
						f.write("</>\n")
				log.info(f"Fallback: wrote text content to {self._filename}")
