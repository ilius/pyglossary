# -*- coding: utf-8 -*-
from __future__ import annotations

import os
import sys
from typing import TYPE_CHECKING

from pyglossary.core import log

if TYPE_CHECKING:
	from collections.abc import Generator

	from pyglossary.glossary_types import EntryType, WriterGlossaryType


__all__ = ["Writer"]


class Writer:
	_encoding: str = "utf-8"
	_key_block_size: int = 32  # KB
	_record_block_size: int = 64  # KB
	_compression_type: int = 2  # zlib

	def __init__(self, glos: WriterGlossaryType) -> None:
		self._glos = glos
		self._filename = ""
		self._entries: dict[str, str] = {}      # Text entries for MDX
		self._data_entries: dict[str, bytes] = {}  # Binary data entries for MDD

	def finish(self) -> None:
		self._filename = ""
		self._entries = {}
		self._data_entries = {}

	def open(self, filename: str) -> None:
		self._filename = filename

	def write(self) -> Generator[None, EntryType, None]:
		"""
		Generator that receives entries and builds MDX dictionary.
		Collects all entries, then writes proper MDX file using mdict-utils.
		"""
		while True:
			entry = yield
			if entry is None:
				break
			if entry.isData():
				# Collect data entries for MDD file
				# PyGlossary data entries have s_word (filename) and data (bytes)
				if hasattr(entry, 's_word') and hasattr(entry, 'data'):
					self._data_entries[entry.s_word] = entry.data
				continue

			# Get all terms (aliases)
			terms = entry.l_term
			if not terms:
				continue

			definition = entry.defi

			# Store the entry for each term/alias
			# MDictWriter expects dict[str, str] for MDX files
			# Multiple aliases point to the same definition (efficient in MDX)
			for term in terms:
				self._entries[term] = definition

		# Now write all entries to proper MDX file
		self._writeMdxFile()

	def _writeMdxFile(self) -> None:
		"""Write collected entries to proper MDX/MDD files using mdict-utils MDictWriter."""
		if not self._entries and not self._data_entries:
			log.warning("No entries to write")
			return

		# Add mdict-utils to path
		mdict_utils_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '..', 'mdict-utils')
		if mdict_utils_path not in sys.path:
			sys.path.insert(0, mdict_utils_path)

		try:
			from .mdict_writer import MDictWriter

			# Get title and description from glossary
			title = self._glos.getInfo("name") or "PyGlossary MDX Export"
			description = self._glos.getInfo("description") or "Generated by PyGlossary"

			# Create MDX file for text entries
			if self._entries:
				mdx_writer = MDictWriter(
					self._entries,
					title=title,
					description=description,
					key_size=self._key_block_size,
					record_size=self._record_block_size,
					encoding=self._encoding,
					compression_type=self._compression_type,
					version="2.0",
					is_mdd=False
				)

				# Write the MDX file
				with open(self._filename, "wb") as outfile:
					mdx_writer.write(outfile)

				log.info(f"Successfully wrote {len(self._entries)} text entries to {self._filename}")

			# Create MDD file for binary data entries
			if self._data_entries:
				# Create MDD filename (same as MDX but with .mdd extension)
				mdd_filename = os.path.splitext(self._filename)[0] + '.mdd'

				# Convert data entries to MDD format (list of dicts with key/path/size/pos)
				mdd_data = []
				for filename, data_bytes in self._data_entries.items():
					mdd_data.append({
						'key': filename,
						'path': data_bytes,  # For MDD, path contains the actual data
						'pos': 0,            # Not used for in-memory data
						'size': len(data_bytes)
					})

				mdd_writer = MDictWriter(
					mdd_data,  # Pass as list of dicts, not dict
					title=title,
					description=description,
					key_size=self._key_block_size,
					record_size=self._record_block_size,
					encoding="",  # MDD doesn't use text encoding
					compression_type=self._compression_type,
					version="2.0",
					is_mdd=True  # This creates MDD format
				)

				# Write the MDD file
				with open(mdd_filename, "wb") as outfile:
					mdd_writer.write(outfile)

				log.info(f"Successfully wrote {len(self._data_entries)} data entries to {mdd_filename}")

		except Exception as e:
			log.error(f"Failed to create MDX/MDD files: {e}")
			import traceback
			traceback.print_exc()
			# Fallback: create a simple text file for text entries
			if self._entries:
				with open(self._filename, 'w', encoding=self._encoding) as f:
					for term, definition in self._entries.items():
						f.write(f"{term}\n")
						for line in definition.split('\n'):
							f.write(f"{line}\n")
						f.write("</>\n")
				log.info(f"Fallback: wrote text content to {self._filename}")
